// fibonnaci
// rdi, rsi, rdx, rcx, r8, r9
(:main
 (:encode
  1 0 // rdi = n
  rax <- rdi
  rax <<= 1
  rax += 1
  return)
 (:encoded_add
  2 0 // rdi = a, rsi = b
  // optimized version
  rax <- rdi
  rax += rsi
  rax -= 1
  return)
 (:fib_impl
  3 3 // rdi = a, rsi = b, rdx = count
  // :fib_impl__enter // for tail call, see below
  // using callee-save registers
  mem rsp 0 <- r12
  mem rsp -8 <- r13
  mem rsp -16 <- r14

  :fib_impl__begin
  r12 <- rdi
  r13 <- rsi
  r14 <- rdx

  // rdx is encoded, encode(2) = 5
  cjump rdx < 5 :fib_impl__ret_b :fib_impl__recur

  :fib_impl__ret_b
  rax <- r13
  // restore callee-save registers
  r12 <- mem rsp 0
  r13 <- mem rsp -8
  r14 <- mem rsp -16
  return

  :fib_impl__recur
  rdi <- r12
  rsi <- r13
  mem rsp -8 <- :fib_impl__ret_addr__encoded_add
  call :encoded_add 2
  :fib_impl__ret_addr__encoded_add

  rdi <- r13
  rsi <- rax
  rdx <- r14
  rdx -= 2 // encode(1) = 3
  // tail recursion!
  goto :fib_impl__begin
  )
 (:fib
  1 0 // rdi = count
  rdx <- rdi
  rdi <- 3
  rsi <- 3

  // tail call!
  // seems to work fine as long as we manually alloc stack space first
  // rsp -= 24 // 3*8 = 24
  // goto :fib_impl__enter

  // boring version:
  mem rsp -8 <- :fib__ret_addr__fib_impl
  call :fib_impl 3
  :fib__ret_addr__fib_impl
  return)
 (:main
  0 0
  rdi <- 4
  mem rsp -8 <- :main__ret_addr__encode
  call :encode 1
  :main__ret_addr__encode

  rdi <- rax
  mem rsp -8 <- :main__ret_addr__fib
  call :fib 1
  :main__ret_addr__fib

  rdi <- rax
  call print 1

  return))

// cjump does NOT do any decoding of its arguments or anything.
// so either both its args must be encoded or both decoded.
