//isprime algorithm from https://en.wikipedia.org/wiki/Primality_test
//Prints numbers 1-50 and prints on the next line whether it is prime
//0 if it is not, 1 if it is.
(:main
    (:main
        0 1
        rdi <- 3
        :run50
            cjump rdi <= 101 :run :fin
        :run
            mem rsp 0 <- rdi
            call print 1
            rdi <- mem rsp 0
            mem rsp -8 <- :isprime_ret
            call :isprime 1
            :isprime_ret
            rdi <- rax
            call print 1
            rdi <- mem rsp 0
            rdi += 2
            goto :run50
        :fin
            return
    )

    (:isprime
        1 3
        cjump rdi = 3 :false :not1
        :not1
        cjump rdi = 5 :true :not2 //5 --> 2 encoded
        :not2
        cjump rdi = 7 :true :not3
        :not3
        rcx <- rdi //check modulo 2 == 0
        rcx &= 3
        cjump 3 <= rcx :noteven :false
        :noteven
        mem rsp -8 <- :check_mod_3
        rsi <- 7
        mem rsp 0 <- rdi
        call :mod 2
        :check_mod_3
        cjump rax = 3 :false :notdiv3
        :notdiv3
        rdi <- mem rsp 0
        rcx <- 11 // 5 encoded, i in algorithm
        r10 <- rcx
        r10 <- 51 //25 encoded
        :check
            cjump r10 <= rdi :continue_loop :true
        :continue_loop
            rsi <- rcx
            mem rsp 0 <- rdi    //save caller save regs needed
            mem rsp 8 <- rcx
            mem rsp 16 <- r10

            mem rsp -8 <- :n_mod_i_ret
            call :mod 2         //n mod i
            :n_mod_i_ret
            cjump rax = 3 :false :check_n_mod_ip2
            :check_n_mod_ip2
            rdi <- mem rsp 0    //restore rdi (n)
            rcx <- mem rsp 8    //restore rcx (i)
            rsi <- rcx
            rsi += 4
            mem rsp 0 <- rdi    //save caller save regs needed
            mem rsp 8 <- rcx
            mem rsp 16 <- r10
            mem rsp -8 <- :check_n_mod_ip2_ret
            call :mod 2
            :check_n_mod_ip2_ret
            cjump rax = 3 :false :incr_i
            :incr_i
            rdi <- mem rsp 0
            rcx <- mem rsp 8
            r10 <- mem rsp 16
            rcx += 12
            r10 <- rcx
            r10 >>= 1       //clear the encoding bit
            r10 <<= 1       //shift back into position
            r10 *= r10      //multiply it by itself
            r10++           //and increment
            goto :check

        :true
            rax <- 3
            goto :ret
        :false
            rax <- 1
            goto :ret
        :ret
            return
    )

    (:mod //a % b, returns 1 (3) if == 0, 0 (1)otherwise
        2 0
        //rdi is a
        //rsi is b
        :cond
            cjump rdi = rsi :then :else
        :then
            rax <- 3
            return
        :else
            cjump rdi < rsi :done :noteql
        :noteql
            rdi >>= 1
            rsi >>= 1
            rdi -= rsi
            rdi <<= 1
            rsi <<= 1
            rsi++
            rdi++

            goto :cond
        :done
            rax <- 1
            return
    )
)
