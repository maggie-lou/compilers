//generates some pythagorean triples with sides less than N (whatever is put into rdi in the main function) using an algorithm I found on the internet
//sources used: https://en.wikipedia.org/wiki/Formulas_for_generating_Pythagorean_triples, https://www.geeksforgeeks.org/generate-pythagorean-triplets/
//(note that this is a simpler algorithm that does not generate all pythagorean triples, namely it will not neccesarily generate two similar triangles (e.g. only 3,4,5 would be generated, not 9,12,15)

(:main
	(:main
		0 0

		//----SET LIMIT (UNENCODED VALUE)----:
			rdi <- 100
		//-----------------------------------
		
		rdi <<= 1 //encode rdi
		rdi++
		mem rsp -8 <- :exit_program
		call :pythagorean 1
		:exit_program
		return
	)
	(:pythagorean //generates some pythagorean triples with sides less than first argument
		1 2
		//rdi = encoded limit

		rdi >>= 1 //decode rdi
		//save callee saved registers
		mem rsp 0 <- r12
		mem rsp 8 <- r13

		r13 <- rdi //put limit in r13

		
		r12 <- 2 //m = 2
		rax <- 0
		mem rsp -8 <- :ret_loop
		:outer_loop
			cjump r13 <= rax :exit_pythagorean //continue looping as long as !(limit <= c), that is c < limit
			rdi <- r12
			rsi <- r13
			call :loop_m_n 2
			:ret_loop
			r12++
		goto :outer_loop

		:exit_pythagorean
		//restore callee saved registers
		r12 <- mem rsp 0
		r13 <- mem rsp 8
		return
	)
	(:loop_m_n //for a particular value of m, loops from n -> m calling print_triple_m_n for each pair, returns the last calculated hypotenuse value (not encoded)
		//rdi - m
		//rsi - limit
		2 3
		rdx <- rsi //rdx = limit

		//we'll be using some values, and they're callee save, so we should store them
		mem rsp 0 <- r12
		mem rsp 8 <- r13
		mem rsp 16 <- r14
		
		r12 <- rdi
		r13 <- 1
		r14 <- rsi
		//now r12 is m, r13 is n (our counter), r14 is the limit
		
		mem rsp -8 <- :print_trip_ret
		
		:loop
			//set arguments to call function with:
			rdi <- r12
			rsi <- r13 
			rdx <- r14
			call :print_triple_m_n 3 
			:print_trip_ret
			r13 += 1 //n++
		cjump r13 < r12 :loop //continue looping if r13 < r12, aka n < m
		
		//restore callee save values
		r12 <- mem rsp 0
		r13 <- mem rsp 8
		r14 <- mem rsp 16

		return //returns the same rax from print triple (the last calculated hypotenuse value)


	)

	(:print_triple_m_n //prints a triple (if present) for a particular m/n value, return the calculated hypotenuse value (not encoded)
		//rdi - m (not encoded, e.g. pass in 5 for 5)
		//rsi - n (not encoded)
		//rdx - limit (not encoded)
		3 3
		r10 <- rdi //store m in r10
		r11 <- rsi //store n in r11
		rdi *= rdi //rdi <- m*m
		rsi *= rsi //rsi <- n*n
		r8 <- rdi //r8 = m*m
		r8 += rsi //r8 = m*m + n*n
		cjump rdx < r8 :end //if c=m*m + n*n is larger than our max allowable value, jump to end without printing anything out
		r9 <- rdi //r9 = m*m
		r9 -= rsi //r9 = m*m - n*n
		r10 *= r11 //r10 = m*n
		r10 *= 2 //r10 = 2*m*n
		//now a = r9, b=r10, c =r8
		
		//encode the calculated values:
		r9 <<= 1
		r9 += 1
		r10 <<= 1
		r10 += 1
		r8 <<=1
		r8 += 1
		//store these values in the stack
		mem rsp 0 <- r9
		mem rsp 8 <- r10
		mem rsp 16 <- r8
		
		rdi <- 7 //we want an array of 3 elements
		rsi <- 0 //doesn't really matter what inital value is, we're gonna change it
		call allocate 2
		//Get values back from stack
		r9 <- mem rsp 0
		r10 <- mem rsp 8
		r8 <- mem rsp 16
		
		//store them in array
		mem rax 8 <- r9
		mem rax 16 <- r10
		mem rax 24 <- r8

		//store array location
		mem rsp 0 <- rax

		//print the array
		rdi <- rax
		call print 1

		rax <- mem rsp 0 //put array location in rax
		r8 <- mem rax 24
		r8 >>= 1
		:end
		rax <- r8
		return //return c
	)
)