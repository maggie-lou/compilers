define void :main() {
  
  :entry
  int64[][][] %m
  
  int64 %r
  int64 %v
  int64 %s
  
  %v <- 21
  call print(%v)
  %m <- new Array(21, 21, 21)
  %r <- call :isInTensor(%m, %v)
  call print(%r)
  %s <- call :sumTensor(%m)
  call print(%s)
  return
}

define int64 :isInTensor (int64[][][] %m, int64 %v) {
  
  :entry
  int64 %l1
  int64 %l2
  int64 %l3
  int64 %l1encoded
  int64 %l2encoded
  int64 %l3encoded
  %l1encoded <- length %m 0
  %l2encoded <- length %m 1
  %l3encoded <- length %m 2
  call print(%l1encoded)
  call print(%l2encoded)
  call print(%l3encoded)
  %l1 <- %l1encoded >> 1
  %l2 <- %l2encoded >> 1
  %l3 <- %l3encoded >> 1
  br :init

  :init 
  int64 %index
  int64 %found
  %found <- 1
  %index <- 0
  br :header1

  :header1
  int64 %check
  %check <- %index < %l1
  br %check :body1 :leave

  :body1
  int64 %index2
  %index2 <- 0
  br :header2

  :header2
  int64 %check2
  %check2 <- %index2 < %l2
  br %check2 :body2 :endBody1

  :body2
  int64 %index3
  %index3 <- 0
  br :header3

  :header3
  int64 %check3
  %check3 <- %index3 < %l3
  br %check3 :body3 :endBody2
 
  :body3
  int64 %e
  int64 %sameE
  %e <- %m[%index][%index2][%index3]
  %sameE <- %e = %v
  br %sameE :setReturn :endBody3
 
  :endBody3
  %index3 <- %index3 + 1
  br :header3

  :endBody2
  %index2 <- %index2 + 1
  br :header2

  :endBody1
  %index <- %index + 1
  br :header1

  :setReturn
  %found <- 3
  br :leave

  :leave
  return %found
}

define int64 :sumTensor(int64[][][] %m) {
  
  :entry
  int64 %l1
  int64 %l2
  int64 %l3
  int64 %l1encoded
  int64 %l2encoded
  int64 %l3encoded
  %l1encoded <- length %m 0
  %l2encoded <- length %m 1
  %l3encoded <- length %m 2
  call print(%l1encoded)
  call print(%l2encoded)
  call print(%l3encoded)
  %l1 <- %l1encoded >> 1
  %l2 <- %l2encoded >> 1
  %l3 <- %l3encoded >> 1
  br :init

  :init 
  int64 %index
  int64 %found
  %sum <- 0
  %index <- 0
  br :header1

  :header1
  int64 %check
  %check <- %index < %l1
  br %check :body1 :leave

  :body1
  int64 %index2
  %index2 <- 0
  br :header2

  :header2
  int64 %check2
  %check2 <- %index2 < %l2
  br %check2 :body2 :endBody1

  :body2
  int64 %index3
  %index3 <- 0
  br :header3

  :header3
  int64 %check3
  %check3 <- %index3 < %l3
  br %check3 :body3 :endBody2
 
  :body3
  int64 %e
  int64 %decoded
  %e <- %m[%index][%index2][%index3]
  %decoded <- %e >> 1
  %sum <- %decoded + %sum
  br :endBody3
 
  :endBody3
  %index3 <- %index3 + 1
  br :header3

  :endBody2
  %index2 <- %index2 + 1
  br :header2

  :endBody1
  %index <- %index + 1
  br :header1

  :leave
  %sum <- %sum << 1
  %sum <- %sum + 1
  return %sum
}

define int64 :encodedLen(int64[][] %m, int64 %dim, int64 %isEncoded) {
  
  :entry
  %encodedLen <- length %m %dim
  %check <- %isEncoded = 0 :notEncoded :encoded
  
  :encoded
  return %encodedLen
  
  :notEncoded
  %notEncodedLen <- %encodedLen >> 1
  return %notEncodedLen
  
}

define int64[][][] :tensorAddition(int64[][][] %m1, int64[][][] %m2) {
  
  :entry
  int64 %l1
  int64 %l2
  int64 %l3
  int64 %l1encoded
  int64 %l2encoded
  int64 %l3encoded
  
  int64 %l1encoded2
  int64 %l2encoded2
  int64 %l3encoded2
  %l1encoded <- length %m1 0
  %l2encoded <- length %m1 1
  %l3encoded <- length %m1 2
  %l1encoded2 <- length %m2 0
  %l2encoded2 <- length %m2 1
  %l3encoded2 <- length %m2 2

  :checkdim1
  %checkDim <- %l1encoded = %l1encoded2
  br %checkDim :checkdim2 :fail

  :checkdim2
  %checkDim <- %l2encoded = %l2encoded2
  br %checkDim :checkdim3 :fail
  
  :checkdim3
  %checkDim <- %l3encoded = %l3encoded2
  br %checkDim :preinit :fail

  :fail
  %failTensor <- new Array(3, 3, 3)
  %failTensor[0][0][0] <- 1
  return %failTensor

  :preinit
  call print(%l1encoded)
  call print(%l2encoded)
  call print(%l3encoded)
  %l1 <- %l1encoded >> 1
  %l2 <- %l2encoded >> 1
  %l3 <- %l3encoded >> 1
  %result <- new Array(%l1encoded, %l2encoded, %l3encoded)
  br :init

  :init 
  int64 %index
  int64 %success
  %success <- 3
  %index <- 0
  br :header1

  :header1
  int64 %check
  %check <- %index < %l1
  br %check :body1 :leave

  :body1
  int64 %index2
  %index2 <- 0
  br :header2

  :header2
  int64 %check2
  %check2 <- %index2 < %l2
  br %check2 :body2 :endBody1

  :body2
  int64 %index3
  %index3 <- 0
  br :header3

  :header3
  int64 %check3
  %check3 <- %index3 < %l3
  br %check3 :body3 :endBody2
 
  :body3
  // Decode element from first m
  int64 %e1
  int64 %decoded1
  int64 %sum
  %e1 <- %m1[%index][%index2][%index3]
  %decoded1 <- %e1 >> 1

  // Decode element from second m
  int64 %e2
  int64 %decoded2
  %e2 <- %m2[%index][%index2][%index3]
  %decoded2 <- %e2 >> 1

  // Sum both elements and set appropriate element in result to sum
  %sum <- %decoded1 + %decoded2
  %result[%index][%index2][%index3] <- %sum
  br :endBody3
 
  :endBody3
  %index3 <- %index3 + 1
  br :header3

  :endBody2
  %index2 <- %index2 + 1
  br :header2

  :endBody1
  %index <- %index + 1
  br :header1

  :leave
  return %result
}
