// leap_year: print leap years from 1900 to 2000
// calculus:
// 1. use euclid algorithm to compute the greatest common divisor.
// 2. find and print all prime factors of a given number
// 3. then print the number of occurance of the most frequent prime factor
// 4. find greatest common divisor of two numbers. instead of Euclid's 

define void :main ( ){
	:entry
	code %fun_pointer
	
	%fun_pointer <- :leap_year
	call %fun_pointer ( )

	%fun_pointer <- :calculus
	call %fun_pointer ( )

	return 
}

define void :leap_year ( ){
 	:entry
  	int64[] %leap_year_array

  	%leap_year_array <- call :calculate_leap (1900, 2000)
  	call print (%leap_year_array)

  	return
}

define void :calculus ( ){
	:entry
	int64 %ep1
	%m0 <- 64
	%m1 <- 72
	%m2 <- 27
	%m3 <- 54
	%m4 <- 37	
	%m5 <- 53

	%ep1 <- call :euclid (%m0, %m1)
	%ep1 <- call :encode (%ep1)
	call print (%ep1)

	int64 %ep2
	%ep2 <- call :euclid (%m2, %m3)
	%ep2 <- call :encode (%ep2)
	call print (%ep2)

	int64 %ep3
	%ep3 <- call :euclid (%m4, %m5)
	%ep3 <- call :encode (%ep3)
	call print (%ep3)

	call :encode_print (%m0)
	call :print_primes (%m0)

	call :encode_print (%m1)
	call :print_primes (%m1)

	call :encode_print (%m2)
	call :print_primes (%m2)

	call :encode_print (%m3)
	call :print_primes (%m3)

	call :encode_print (%m4)
	call :print_primes (%m4)

	call :encode_print (%m5)
	call :print_primes (%m5)

	call :encode_print (%m0)
	call :encode_print (%m1)
	int64 %cd12
	%cd12 <- call :common_divisor (%m0,%m1)
	call :encode_print (%cd12)

	call :encode_print (%m2)
	call :encode_print (%m3)
	int64 %cd34
	 %cd34 <- call :common_divisor (%m2,%m3)
	call :encode_print (%cd34)

	call :encode_print (%m4)
	call :encode_print (%m5)
	int64 %cd56
	%cd56 <- call :common_divisor (%m4,%m5)
	call :encode_print (%cd56)


	return
}

define int64[] :calculate_leap (int64 %start_year, int64 %end_year){
	:entry
	int64[]	%array

	%array <- call :create_array (%start_year, %end_year)
	call :fill_array (%array, %start_year, %end_year)
	
	return %array 		
}

define int64[] :create_array (int64 %start_year, int64 %end_year){
	:entry
	int64 	%size
	int64[] %array

	%size <- %end_year - %start_year
	%size <- %size >> 2
	%size <- %size + 1
	
	%size <- call :encode (%size)
	//call print (%size)

	%array <- new Array(%size)
	
	return %array
}

define int64 :encode (int64 %num_to_encode){
	:entry
	%num_to_encode <- %num_to_encode << 1
	%num_to_encode <- %num_to_encode + 1
	return %num_to_encode
}

define void :encode_print (int64 %unencode_to_print){
	:entry
	%unencode_to_print <- call :encode (%unencode_to_print)
	call print (%unencode_to_print)
	return
}

define void :fill_array (int64[] %array, int64 %current_year, int64 %end_year){
	:entry
	int64 %index
	int64 %is_leap
	int64 %i
	int64 %encode_current_year
	
	%index <- 0
	br :loop_start
	
	:loop_start
	%i <- %current_year <= %end_year
	br %i :calc :ret

	:calc
	%is_leap <- call :is_leap_year(%current_year)
	br %is_leap :leap :not_leap

	:not_leap
	br :continue_loop

	:leap
	%encode_current_year <- call :encode (%current_year)
	%array[%index] <- %encode_current_year
	%index <- %index + 1
	br :continue_loop

	:continue_loop
	%current_year <- %current_year + 1
	br :loop_start

	:ret
	return
}

define int64 :is_leap_year (int64 %year){
	:entry
	int64 %flag
	int64 %i

	%flag <- %year
	%flag <- %flag & 15  //// mod 16

	%i <- %flag = 0
	br %i :yes :may_not_leap  

	:may_not_leap
	%flag <- %year
	%flag <- %flag >> 2
	br :loop_mod_25

	:loop_mod_25
	%i <- %flag = 25
	br %i :no :minus_25

	:minus_25
	%i <- 25 < %flag
	br %i :loop_minus_25 :may_leap

	:loop_minus_25
	%flag <- %flag - 25
	br :loop_mod_25 

	:may_leap
	%flag <- %year
	%flag <- %flag & 3
	
	%i <- %flag = 0
	br %i :yes :no 

	:yes
	return 1

	:no
	return 0
}

define int64 :euclid (int64 %i0, int64 %i1){
	:entry
	int64 %foo
	int64 %bar
	int64 %flag
	int64 %flag2
	int64 %flag3
	int64 %temp
	
	%foo <- %i0
	%bar <- %i1
	br :start

	:start
	%flag3 <- %foo = %bar
	br %flag3 :ret :cont

	:cont
	%flag <- %foo > %bar
	br %flag :foogbar :cont2

	:cont2
	%temp <- %foo
	%foo <- %bar
	%bar <- %temp
	br :foogbar

	:foogbar
	%temp <- %foo - %bar
	%foo <- %bar
	%bar <- %temp

	%flag2 <- 1
	br %flag2 :start :ret

	:ret
	return %foo
}

define int64 :customer_divide (int64 %dividend, int64 %divisor){
	:entry
	int64 %ret
	int64 %flg

	%ret <- 0
	br :cus_start

	:cus_start
	%dividend <- %dividend - %divisor
	%ret <- %ret + 1
	%flg <- %dividend < %divisor
	br %flg :cus_ret :cus_start

	:cus_ret
	return %ret
}


define int64 :sqrt (int64 %var){
	:entry
	int64 %i
	int64 %i2
	int64 %sqrt_flag

	%i <- 0
	br :start_label

	:start_label
	%i <- %i + 1
	%i2 <- %i * %i
	%sqrt_flag <- %i2 <= %var
	br %sqrt_flag :start_label :ret_label
	
	:ret_label
	return %i
}

define int64 :divisible (int64 %dividend, int64 %divisor){
	:div_loop_start
	int64 %i
	%i <- %dividend < %divisor
	br %i :div_ret_no :div_to_equal

	:div_ret_no
	return 0

	:div_to_equal
	%i <- %divisor = %dividend
	br %i :div_ret_true :div_to_loop

	:div_ret_true
	return 1

	:div_to_loop
	%dividend <- %dividend - %divisor
	br :div_loop_start	
}

define int64 :greater (int64 %foo, int64 %bar){
	:entry
	int64 %flag

	%flag <- %foo >= %bar
	br %flag :foogeqbar :nfoogeqbar
	
	:nfoogeqbar
	return %bar
	
	:foogeqbar
	return %foo
}

define int64 :getfreq (int64 %var, int64 %c1, int64 %c2, int64 %c3, int64 %c4, int64 %c5){
	:entry
	int64 %ret 
	int64 %ret2
	int64 %ret3
	int64 %ret4
	int64 %ret5

	%ret 	<- %c1 = %var
	%ret2	<- %c2 = %var
	%ret3	<- %c3 = %var
	%ret4	<- %c4 = %var
	%ret5	<- %c5 = %var
	
	%ret <- %ret + %ret2
	%ret <- %ret + %ret3
	%ret <- %ret + %ret4
	%ret <- %ret + %ret5
	
	return %ret
}

define int64 :common_divisor (int64 %foo, int64 %bar){
	:entry
	int64 %com_div
	int64 %cd
	int64 %com_g
	int64 %temp
	int64 %com_sqrt
	int64 %div_foo
	int64 %div_bar
	int64 %both
	int64 %last_flag

	%com_div <- 1
	%cd <- 2	
	%com_g <- %foo < %bar
	br %com_g :exchange :step_over

	:exchange	
	%temp <- %foo
	%foo <- %bar
	%bar <- %temp
	br :step_over

	:step_over
	%com_sqrt <- call :sqrt (%foo)
	br :com_start
	
	:com_start
	%div_foo <- call :divisible (%foo, %cd)
	%div_bar <- call :divisible (%bar, %cd)
	%both <- %div_foo * %div_bar
	br %both :com_cont :com_inc

	:com_cont
	%com_div <- %com_div * %cd
	%foo <- call :customer_divide(%foo, %cd)
	%bar <- call :customer_divide(%bar, %cd)
	br :com_start	

	:com_inc
	%cd <- %cd + 1
	%last_flag <- %cd > %com_sqrt
	br %last_flag :com_ret :com_start_2

	:com_start_2	

	br :com_start

	:com_ret

	return %com_div
}

define void :print_primes(int64 %num){
	:entry

	int64 %d
	%d <- 2
	int64 %g_freq
	%g_freq <- 0
	int64 %orig_num
	%orig_num <- %num
	int64 %most_freq
	%most_freq <- 0
	int64 %curr_freq
	%curr_freq <- 0
	int64 %cnt_curr
	%cnt_curr <- 0

	int64 %num_sqrt
	%num_sqrt <- call :sqrt(%num)
	br :init

	:init

	int64 %ini_ret
	%ini_ret <- %d > %orig_num
	br %ini_ret :ini_return :ini_cont

	:ini_cont

	int64 %divisible_flag
	%divisible_flag <- call :divisible(%num, %d)
	br %divisible_flag :to_print :not_to_print

	:to_print
	call :encode_print(%d)
	int64 %new_num
	%new_num <- call :customer_divide(%num, %d)
	%num <- %new_num
	%curr_freq <- %curr_freq + 1
	br :init

	:not_to_print
	%d <- %d + 1
	int64 %curr_most
	%curr_most <- %curr_freq > %most_freq
	br %curr_most :update :do_not_update

	:update
	%most_freq <- %curr_freq
	br :do_not_update

	:do_not_update
	%curr_freq <- 0
	br :init

	:ini_return

	call :encode_print (%most_freq)

	return
}