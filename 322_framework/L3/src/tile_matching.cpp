// Tile_node
// type
// operand
// children
// associated instruction
// cost
// size
// other constraints

// sort tiles by size & cost

// tile & tree matching
// recursion
// helper function that takes in two Nodes and compare type & operand
// call the helper function on children

// maximal munch
// start at root
// start from the largest tile and try to match
// try to match subtrees
// 
// vector<Instruction*> maximal_munching(Tree_node* n){
//
// }
