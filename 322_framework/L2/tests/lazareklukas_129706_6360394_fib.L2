// fibonnaci
// rdi, rsi, rdx, rcx, r8, r9
(:main
 (:encode
  1 0 // rdi = n
  %n <- rdi
  %n <<= 1
  %n += 1
  rax <- %n
  return)
 (:encoded_add
  2 0 // rdi = a, rsi = b
  // optimized version
  %a <- rdi
  %b <- rsi
  %a += %b
  %a -= 1
  rax <- %a
  return)
 (:fib_impl
  3 0 // rdi = a, rsi = b, rdx = count
  // :fib_impl__enter // for tail call, see below
  :fib_impl__begin
  %a <- rdi
  %b <- rsi
  %count <- rdx

  // rdx is encoded, encode(2) = 5
  cjump %count < 5 :fib_impl__ret_b :fib_impl__recur

  :fib_impl__ret_b
  rax <- %b
  return

  :fib_impl__recur
  rdi <- %a
  rsi <- %b
  mem rsp -8 <- :fib_impl__ret_addr__encoded_add
  call :encoded_add 2
  :fib_impl__ret_addr__encoded_add
  %new_b <- rax

  rdi <- %b
  rsi <- %new_b
  rdx <- %count
  rdx -= 2 // encode(1) = 3
  // tail recursion!
  goto :fib_impl__begin
  )
 (:fib
  1 0 // rdi = count
  rdx <- rdi
  rdi <- 3
  rsi <- 3

  // tail call!
  // seems to work fine as long as we manually alloc stack space first
  // rsp -= 24 // 3*8 = 24
  // goto :fib_impl__enter

  // boring version:
  mem rsp -8 <- :fib__ret_addr__fib_impl
  call :fib_impl 3
  :fib__ret_addr__fib_impl
  return)
 (:main
  0 0
  %fib_arg <- 4

  rdi <- %fib_arg
  mem rsp -8 <- :main__ret_addr__encode
  call :encode 1
  :main__ret_addr__encode
  %encoded_fib_arg <- rax

  rdi <- %encoded_fib_arg
  mem rsp -8 <- :main__ret_addr__fib
  call :fib 1
  :main__ret_addr__fib
  %fib_res <- rax

  rdi <- %fib_res
  call print 1

  return))

// cjump does NOT do any decoding of its arguments or anything.
// so either both its args must be encoded or both decoded.
