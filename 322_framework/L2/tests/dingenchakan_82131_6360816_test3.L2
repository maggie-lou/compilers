(:main

(:main
    0 0

    // IS 0 PRIME?
    rdi <- 0

    mem rsp -8 <- :print_is_prime0
    call :print_is_prime 1
    :print_is_prime0

    // IS 1 PRIME?
    rdi <- 1

    mem rsp -8 <- :print_is_prime1
    call :print_is_prime 1
    :print_is_prime1

    // IS 2 PRIME?
    rdi <- 2

    mem rsp -8 <- :print_is_prime2
    call :print_is_prime 1
    :print_is_prime2

    // IS 3 PRIME?
    rdi <- 3

    mem rsp -8 <- :print_is_prime3
    call :print_is_prime 1
    :print_is_prime3

    // IS 4 PRIME?
    rdi <- 4

    mem rsp -8 <- :print_is_prime4
    call :print_is_prime 1
    :print_is_prime4

    // IS 5 PRIME?
    rdi <- 5

    mem rsp -8 <- :print_is_prime5
    call :print_is_prime 1
    :print_is_prime5

    // IS 6 PRIME?
    rdi <- 6

    mem rsp -8 <- :print_is_prime6
    call :print_is_prime 1
    :print_is_prime6

    // IS 7 PRIME?
    rdi <- 7

    mem rsp -8 <- :print_is_prime7
    call :print_is_prime 1
    :print_is_prime7

    // IS 8 PRIME?
    rdi <- 8

    mem rsp -8 <- :print_is_prime8
    call :print_is_prime 1
    :print_is_prime8

    return)


(:print_is_prime
    1 0
    mem rsp -8 <- :is_prime_return
    call :is_prime 1
    :is_prime_return
    %toEncode <- rax

    %toEncode *= 2
    %toEncode++
    rdi <- %toEncode
    call print 1
    return)

(:divides
    2 0
    %firstArg <- rdi
    %secondArg <- rsi
    cjump %secondArg < 0 :return_0 // return 0 if dividing a negative integer
    cjump %firstArg <= 0 :return_0 // return 0 if dividing by a non-positive integer
    cjump %secondArg < %firstArg :return_0 // return 0 if divisor is greater than dividend
    cjump %firstArg = 1 :return_1 :subtract_once // return 1 if dividing by 1

    :subtract_once
    %secondArg -= %firstArg
    cjump %secondArg = 0 :return_1 // return 1 if the remainder is 0
    cjump %firstArg <= %secondArg :subtract_once // subtract again if current remainder >= divisor
    goto :return_0

    :return_0
    rax <- 0
    goto :end_function

    :return_1
    rax <- 1
    goto :end_function

    :end_function
    return)

(:is_prime
    1 0
    %firstArg <- rdi
    cjump %firstArg < 2 :return_0_prime // no number less than 2 is prime
    cjump %firstArg <= 2 :return_1_prime // 2 is prime
    r12 <- %firstArg // save the number in question
    %test <- 2 // start of the test
    :loop
    rdi <- %test // pass argument
    rsi <- r12 // pass argument

    mem rsp -8 <- :divides_return2
    call :divides 2
    :divides_return2
    cjump rax = 1 :return_0_prime // not prime if has a divisor
    %test++ // increase test number
    %temp <- %test // temporary save to see if we are at the end
    %temp >>= 1 // divide by 2
    cjump %temp < r12 :return_1_prime :loop

    :return_0_prime
    rax <- 0
    goto :end_function_prime

    :return_1_prime
    rax <- 1
    goto :end_function_prime

    :end_function_prime
    return
)
)
